<!DOCTYPE html><html lang="ko" class="__className_aaf875"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/eaeb131c1871b7f2-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/4c92cc5b866ba25d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-3917685bbbc11c84.js"/><script src="/_next/static/chunks/f14ca715-be5973fc1a0704a8.js" async=""></script><script src="/_next/static/chunks/465-109120b81993a3e4.js" async=""></script><script src="/_next/static/chunks/main-app-1d95d3bcd99806f2.js" async=""></script><script src="/_next/static/chunks/618-6a6cc50adaace762.js" async=""></script><script src="/_next/static/chunks/app/page-3813dd42f0b14061.js" async=""></script><script src="/_next/static/chunks/969-108d58b1f108e1d8.js" async=""></script><script src="/_next/static/chunks/app/layout-a46294d93785b42a.js" async=""></script><title>Home | Better code coffee 블로그</title><meta name="description" content="전체 포스트 목록을 볼 수 있습니다."/><link rel="icon" href="/images/icons/favicons/favicon.ico"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="flex flex-col w-full max-w-screen-lg mx-auto"><header class="relative flex justify-center items-center p-8"><a class="flex flex-col items-center text-5xl" href="/"><h1 class="__className_5cd26d">Better code coffee</h1><p class="text-base mt-3">A blog by someone who strives for and enjoys writing better code and loves coffee</p></a><div class="absolute top-11 right-8 flex items-center gap-3 max-md:hidden"><a href="https://github.com/soyoung-baker"><img alt="GitHub logo" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/ic_github_24.3c455590.svg"/></a><a href="https://www.linkedin.com/in/soyoung-jung-baker"><img alt="LinkedIn logo" loading="lazy" width="24" height="24" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/ic_linkedin_24.3e548cc1.svg"/></a></div></header><main class="grow max-lg:px-3"><section class="pt-16 pb-20"><h2 class="font-extrabold text-2xl">POST</h2><ul class="flex flex-col gap-10 mt-6"><li><a href="/posts/2024-07-04-pnpm-action-node-version"><article><h3 class="text-xl font-semibold">pnpm action node version 에러</h3><time class="mt-1 text-sm text-zinc-400">2024-07-04</time><p class="mt-4 line-clamp-3 text-zinc-700">PR을 올린 후 GitHub Actions가 실패하는 문제가 발생했다. 로그를 확인해보니 install pnpm 단계에서 에러가 발생한 것이었다. 내용은 아래와 같은데 어제까지 잘 작동하던 액션이 갑자기 에러를 발생시키니, 특별한 설정 변경이 없었음에도 원인을 찾기 위해 구글링을 시작했다. 똑같은 증상으로 issue 를 올린 글을 확인했다. 문제의 원인은 pnpm/action-setup 이슈에서 동일한 증상을 겪고 있는 사람들의 글을 통해 확인할 수 있었다. 해결책은 checkout 액션을 최신 버전인 v4로 업그레이드하는 것이었다. 실제로 버전을 올린 후 문제가 해결되었다. 왜 이런 문제가 발생했는지 알아보았다. GitHub Actions와 Node.js 버전 전환 작년부터 올해 GitHub Actions는 Node.js 20으로 전환하는 과정을 진행 중이었다. [GitHub Actions: Transitioning from Node 16 to Node 20](https://github.blog/changelog/2023-09-22-github-actions-transitioning-from-node-16-to-node-20/) 이러한 GitHub Actions 의 소식으로 pnpm/action-setup 에서는 아래와 같은 대화가 있었다. [node20 support](https://github.com/pnpm/action-setup/issues/99#issuecomment-1737700746) 그리고 2024년 5월 17일에 [Updated dates for Actions runner using Node20 instead of Node16 by default](https://github.blog/changelog/2024-05-17-updated-dates-for-actions-runner-using-node20-instead-of-node16-by-default/) 업데이트 글이 올라왔다. 따라서 Node.js 16으로 실행되던 pnpm/action-s</p></article></a></li><li><a href="/posts/2024-06-29-useRef"><article><h3 class="text-xl font-semibold">useRef 의 3가지 타입</h3><time class="mt-1 text-sm text-zinc-400">2024-06-29</time><p class="mt-4 line-clamp-3 text-zinc-700">React의 `useRef` 훅은 컴포넌트 렌더링 사이에 값을 저장할 수 있는 방법을 제공한다. 이는 렌더링 간에 정보를 보존해야 하지만 리렌더링을 촉발하지 않아야 하는 경우에 유용하다. `useRef`의 특징으로 아래 3가지를 가지고 있다. 요약하면, `useRef`는 React의 생명주기와 독립적으로 작동하며, 사이드 이펙트를 발생시킬 수 있는 훅이다. 공식문서에는 &quot;초기화를 제외하고 렌더링 중에 `ref.current` 를 쓰거나 읽지 마세요.&quot; 라고 경고하는데, 이는 컴포넌트의 동작을 예측할 수 없게 만들기 때문이다. react 소스 코드를 통해 `useRef` 부분을 살펴보면 `useRef`는 `current` 속성을 가진 객체를 반환한다. export function useRef&lt;T&gt;(initialValue: T): { current: T } {   const dispatcher = resolveDispatcher();   return dispatcher.useRef(initialValue); } 이 객체는 초기화된 값을 가진 상태로 반환되며, 값이 원시 타입일 경우 새로운 값이 할당될 수 있지만 객체일 경우 객체의 프로퍼티가 변경되더라도 객체 자체는 변경되지 않는다. 다시 정리하면 `useRef`는 같은 객체가 유지되어야 하기 때문에, `current` 속성을 이용해서 지속할 값을 저장한다. 이 `current` 속성을 가진 객체 자체는 변하지 않으며, 객체의 프로퍼티를 변경하더라도 참조 자체는 유지된다. 따라서 객체의 프로퍼티가 변경되어도 리렌더링이 발생하지 않는다. 이 `useRef` 를 사용할 때 초기화 하는 방법에는 아래 3가지 방법이 있다. 세 가지 경우 모두 유효하지만, 초기값으로 `null`을 넣는 경우와 그렇지 않은 경우의 차이점은 무엇일까? 여기서 `useRef` 가 가질 수 있는 값 타입을 보기 위해 타입 정보에 들어가면 아래 3가지로 나뉘는 것을 볼 수 있다.  * `useRef`는 전달된 인수(`initialValue`)로 초</p></article></a></li><li><a href="/posts/2024-06-16-react-useState"><article><h3 class="text-xl font-semibold">useState</h3><time class="mt-1 text-sm text-zinc-400">2024-06-16</time><p class="mt-4 line-clamp-3 text-zinc-700">`useState`는 초기값을 매개변수로 받고, `[value, setState]` 형식의 배열을 리턴한다.   // do someting   return [value, setState]; } 우리가 `useState`를 사용할 때, 아래 코드처럼 그 `state`에 어울리는 이름을 붙여서 사용한다. 이게 가능한 이유는 배열은 속성 이름이 아닌 인덱스 위치로 구조 분해 할당이 가능하기 때문이다. 첫 번째, 두 번째 요소가 무슨 이름으로 지정되든 상관없이 배열에서는 0번째, 1번째 값을 반환한다. 반면, 객체로 구조 분해 할당을 실행하면 리턴 문에서 지정한 `key, value` 형태를 그대로 유지해야 한다.   // do someting   return { value, setState }; } 이렇게 되면 우리는 매번 아래처럼 이름을 재할당해줘야 한다.   // do someting   return { value, setState }; } 이러한 불필요한 작업 없이 배열을 통해 값을 받아서 사용하는 것이다. 다시 돌아와서, 받은 초기값으로 `value`를 지정하고 `setState`에는 새로운 값이 들어오면 기존 `value`에 할당하는 방식일 것이다.   let value = initValue;   function setState(newValue) {     value = newValue;   }   return [value, setState]; } 이제 이렇게 동작이 되는지 컴포넌트를 만들어서 확인해보자.   const [number, setNumber] = useState(0);   return {     onClick: () =&gt; {       setNumber(1);     },     render: () =&gt; {       console.log(number); // 0 0     },   }; } A.render(); A.onClick(); A.render(); `onClick`을 실행했음에도 여전히 0이 출력되는 것을 볼 수 있다. 이유는 `con</p></article></a></li><li><a href="/posts/2024-05-19-jest-act"><article><h3 class="text-xl font-semibold">UserEvent 의 act 경고</h3><time class="mt-1 text-sm text-zinc-400">2024-05-19</time><p class="mt-4 line-clamp-3 text-zinc-700">import { useState } from &quot;react&quot;; import { act, fireEvent, render, screen } from &quot;@testing-library/react&quot;; import userEvent from &quot;@testing-library/user-event&quot;;   const [isActive, setIsActive] = useState(false);   return (     &lt;button onClick={() =&gt; setIsActive((prev) =&gt; !prev)}&gt;       {isActive ? &quot;OFF&quot; : &quot;ON&quot;}     &lt;/button&gt;   ); }; describe(&quot;Button&quot;, () =&gt; {   it(&quot;UserEvent with act&quot;, async () =&gt; {     render(&lt;TestComponent /&gt;);     const button = screen.getByRole(&quot;button&quot;, { name: &quot;ON&quot; });     expect(button).toBeInTheDocument();     await act(async () =&gt; await userEvent.click(button));     expect(button).toHaveTextContent(&quot;OFF&quot;);   });   it(&quot;UserEvent without act&quot;, async () =&gt; {     render(&lt;TestComponent /&gt;);     const button = screen.getByRole(&quot;button&quot;, { name: &quot;ON&quot; });     expect(button).toBeInTheDocument();     await userEvent.click(button);     expect(button).toHaveTextContent(&quot;OFF&quot;);   });   it(&quot;UserEvent with session without act&quot;, async () =&gt; {     const user = userEvent.setup()</p></article></a></li><li><a href="/posts/2024-05-01-google-translate-react"><article><h3 class="text-xl font-semibold">리액트와 구글 번역기 충돌로 인한 에러 해결 방법</h3><time class="mt-1 text-sm text-zinc-400">2024-05-01</time><p class="mt-4 line-clamp-3 text-zinc-700">최근 유저가 페이지를 이동하다가 갑자기 아래와 같은 에러 문구로 에러 페이지가 뜬다는 보고가 들어왔다. NotFoundError Failed to execute &#x27;insertBefore&#x27; on &#x27;Node&#x27;: The node before which the new node is to be inserted is not a child of this node. 관련해서 검색을 해보니 리액트로 개발된 페이지에서 구글 번역기를 사용할 경우 생기는 문제였다. 구글과 리액트에서도 이미 이 문제에 대해서 알고 있는 상태이지만 리액트와 구글, 두 팀은 이 문제를 고칠 생각은 없어 보였다. 위 링크 내용을 요약하면 구글 번역기가 동작하면서 번역된 내용이 담긴 텍스트 노드를 `&lt;font&gt;` 태그에 감싸는데 이때 리액트는 더이상 자식 요소가 아닌 텍스트 노드에 대한 참조를 유지해서 생긴 문제다. 1. 구글 번역기를 사용하면 텍스트 노드는 `&lt;font&gt;` 태그로 감싸진다. 2. 리액트는 더이상 자식 요소가 아닌 텍스트 노드를 참조를 계속 유지한다. 문제를 분석하기 전에 `insertBefore` 메소드에 대해서 알아보자. `insertBefore` 은 특정 노드를 참조 노드의 앞에 사용될 때 사용되는 메소드다. [mdn - Node: insertBefore() method](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) parentNode.insertBefore(newNode, referenceNode);   * 삽입할 새로운 노드   * 이미 DOM 에 존재하는 노드라면 현재 위치에서 제거되고 새로운 위치에 삽입된다.   * 참조 노드, 이 노드 앞에 `newNode` 가 삽입된다.   * 만약 `null` 일 경우, `newNode` 는 부모노드의 자식 목록의 마지막에 추가된다. 위 특징대로 간단하게 사용법을 익히면 아래와 같다.   &lt;span id=&quot;childElement&quot;&gt;안녕!&lt;/span&gt;   const</p></article></a></li><li><a href="/posts/2024-04-04-git-action"><article><h3 class="text-xl font-semibold">SSH Key 및 Personal Access Token 설정</h3><time class="mt-1 text-sm text-zinc-400">2024-04-04</time><p class="mt-4 line-clamp-3 text-zinc-700">회사에서는 공용 키를 사용하는 것이 이상적이지만, 멤버 개인의 키를 사용하는 경우도 있을 수 있다. 이때 해당 멤버가 퇴사하면서 계정이 삭제되면 해당 멤버의 키는 모두 유효하지 않아 액션이 실패하게 된다. 따라서 아래 방법을 통해 키를 대체해야 한다. 커밋을 푸시할 때마다 아이디와 비밀번호를 입력해야 한다면 매우 불편할 것이다. SSH 키를 사용하면 이러한 불편함을 해소할 수 있다. 다음은 SSH 키를 설정하는 과정이다. vi ~/.ssh id_rsa id_rsa.pub GitHub 프로필 메뉴에서 Settings &gt; SSH and GPG keys로 이동한다. New SSH key 버튼을 클릭한다. `id_rsa.pub` 파일의 내용을 그대로 복사하여 붙여넣는다. SSH 키를 추가한 후 회사 권한을 부여해야 한다. 권한이 부여되지 않은 경우 흰색 텍스트로 Authorize 상태이다. 해당 버튼을 클릭하여 붉은 글씨로 Deauthorize 상태로 변경해야 한다. (버튼이 아닌 라벨처럼 마치 붉은 글씨가 권한이 취소된 상태처럼 보이는게 UI 가 매우 아쉽다) 등록이 끝나면 보통 바로 위 사진처럼 키가 초록색이 아닌 아래 사진처럼 흰색인데 아직 ssh 키를 사용(커밋 푸쉬 등)하지 않아서니깐 걱정하지 않아도 된다. Settings 메뉴에서 Developer settings로 이동한다. Personal access tokens &gt; Tokens (classic) &gt; Generate new token 버튼을 클릭한다. 토큰을 생성한 후 회사 권한을 활성화한다. 레포지토리 설정으로 이동하여 Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret 버튼을 클릭한다. key 이름은 상관없다. 다만 workflows 에서 `secrets.` 뒤에 설정할 변수 이름과 key 가 동일해야 한다. `id_rsa` 텍스트를 그대로 복사하여 붙여넣는다. 이때 `----BEGIN` 과 `-----END` 까지 복사해서 붙여넣어</p></article></a></li><li><a href="/posts/2024-03-08-mock"><article><h3 class="text-xl font-semibold">mock 이 왜 필요할까?</h3><time class="mt-1 text-sm text-zinc-400">2024-03-08</time><p class="mt-4 line-clamp-3 text-zinc-700">디자인에서는 mockup이라는 용어가 있다. 제품 디자인 수업 때, 팀원들과 함께 목업실에서 디자인한 아이디어를 형상화하기 위해 매달렸던 그때가 기억난다. 디자인에서 mockup 과정이 필요한 이유는 한 번에 요구사항에 맞게 제품을 만들 수 없기 때문이다. mockup 과정 없이 실제 제품을 만들면 요구사항과 다르다는 사실을 발견할 때마다 매번 수정해야 하므로 비용이 많이 들 것이다. 그러므로 mockup을 통해 팀원들과 함께 요구사항의 부족한 부분을 찾아내고 보완해 나가는 과정을 거치게 된다. 이러한 끊임없는 디자인 검증 과정을 거쳐 비용을 절감한 후에 프로토타입과 실제 제품을 생산할 수 있다. 개발도 이와 유사하다. 한 번에 요구사항에 맞게 개발하는 것은 어렵다. 개발에선 &#x27;mockup&#x27;이 아닌 &#x27;mock&#x27;이라는 용어를 사용한다. 이것은 가짜 데이터를 생성하는 것으로, 실제 데이터가 아니라 모의 데이터나 API 요청과 같은 것을 의미한다. 프론트엔드 개발자들은 주로 API 개발 전에 실제 API 데이터 대신 가짜 데이터나 모의 API를 사용하여 작업한다. 이렇게 하면 mock 데이터나 mock API를 사용하여 사전에 작업할 수 있다. 이와 같이 &#x27;mock&#x27;이라는 개념은 실제 제품이나 데이터를 모방하여 만든 것으로, 필요한 상황에 도구로 사용된다. 개발에 앞서, 작업 방법을 구상하고 스펙에 대한 검증이 필요한 부분을 문서를 통해 명확히 작성한다. 이후 수정이 필요한 부분이 발생하면 팀원들과 회의를 통해 스펙을 다시 확인하고 수정해 나간다. 팀 전체가 스펙에 대해 명확하게 이해하면 개발을 시작한다. 초기에는 백엔드에서 데이터를 받을 수 없을테니 mock 데이터를 사용하여 개발을 진행한다. 테스트 코드를 작성할 수 있다면 테스트 코드를 통해 예상한 mock 데이터를 활용하여 개발을 진행하고, 스펙에 미흡한 부분이 발견되면 즉시 팀원들과 다시 논의를 거쳐 수정한다. 또한, 중간에 스펙 변경 요청이 들어오면 그에 따라 새로운 기능을 추가해서 테스트 결과를 보면 어</p></article></a></li><li><a href="/posts/2024-02-10-date"><article><h3 class="text-xl font-semibold">Date: &quot;네가 뭘 좋아할지 몰라서 다 준비했어&quot;</h3><time class="mt-1 text-sm text-zinc-400">2024-02-10</time><p class="mt-4 line-clamp-3 text-zinc-700">GMT는 태양을 기준으로 한 그리니치 평균시로, 영국 그리니치 천문대를 지나는 본초자오선(경도 0도)을 기준으로 한다. 지구를 약 15도씩 나눠서 24개의 시간대를 만든 것이다. TMI 로 &#x27;본초자오선&#x27;이라는 용어가 입에 잘 붙지 않아 찾아보니 다음과 같은 의미를 담고 있다. 즉, 본초자오선(本初子午線)은 북쪽과 남쪽을 잇는 선 중에서 가장 처음이 되는 기준선이라는 뜻이다. 1967년 &#x27;초&#x27; 라는 시간 단위 정의가 바뀌었는데 기존에는 지구가 한 바퀴 자전하는 것을 24시간으로 삼았지만 태양이 뜨고 지는 시간, 즉 지구가 한 바퀴 자전하는 시간을 `하루를 24시간 * 1시간 60분 * 1분 60초 = 86,400` 으로 나눈 단위였다. 하지만 과학자들은 지구의 자전의 속도가 미세하게 느려지고 있다는 것을 알게됐고 우주 어디에서도 절대 변하지 않는 시간 단위, 원자 시계 기반 시계 기준(UTC)을 만들었다. UTC는 원자 시계를 기준으로 한 전 세계 시간의 기준이다. 세슘 원자의 진동수를 기준이 원자 시계다.(TMI: 세슘 원자로 정한 이유는 세슘 원자는 온도, 압력 같은 외부 조건에 영향을 받지 않고 원자의 진동 주기가 매우 안정적으로 일정하기 때문이라고 한다.) 지구의 자전 속도에 따라 미세하게 느려진 GMT 와 다르게 UTC 는 지구의 자전 속도와 원자 시계의 간격을 위해 필요할 때, 6월 30일 혹은 12월 31일에 1초를 추가하거나 삭제하면서 &#x27;초&#x27;의 정의를 바꾸지 않고 시간을 보정할 수 있다. UTC+0:00이 영국 시간이다. 이 시간대를 기준으로 각 지역의 시차를 정하는데, 예를 들어 한국은 영국보다 9시간 빠른 UTC+09:00이다. (빠르다는 것은 영국보다 한국이 9시간 앞서 있다, 지났다는 것을 의미) ISO 8601은 국제 표준으로 정의된 날짜 및 시간 표기 형식이다. 이 형식은 다음과 같다: 날짜: yyyy-mm-dd 시간: hh:mm:ss (날짜와 시간 사이에 T를 사용) 예: 2023-12-01T09:00:00Z (Z는 UTC 시간을 나타</p></article></a></li><li><a href="/posts/2024-01-28-debug-tool"><article><h3 class="text-xl font-semibold">VSCode 에서 타입스크립트 디버깅하기</h3><time class="mt-1 text-sm text-zinc-400">2024-01-28</time><p class="mt-4 line-clamp-3 text-zinc-700">VSCode에서 타입스크립트로 작성한 코드를 디버그하려고 하면 에러가 발생한다.   return `${name}.github.io`; } printBlogURL(blogName); VSCode에서 타입스크립트 디버그를 어떻게 할 수 있을까? [공식문서](https://code.visualstudio.com/docs/typescript/typescript-debugging)에는 아래와 같이 적혀있다. &gt; VS Code has built-in debugging support for the Node.js runtime and can debug JavaScript, TypeScript, or any other language that gets transpiled to JavaScript. VSCode는 Node.js 런타임에 대한 내장 디버깅 지원을 제공하며 JavaScript, TypeScript 또는 JavaScript로 변환되는 다른 언어를 디버깅할 수 있다. &gt; Visual Studio Code supports TypeScript debugging through its built-in Node.js debugger and Edge and Chrome debugger. Visual Studio Code는 내장된 Node.js 디버거와 Edge 및 Chrome 디버거를 통해 TypeScript 디버깅을 지원한다. 1. VSCode는 자바스크립트 런타임 환경에 내장한 디버깅을 지원한다. 2. 즉, 타입스크립트로 작성한 코드는 자바스크립트로 변환된 상태여야 자바스크립트 런타임 환경에 내장한 디버깅을 쓸 수 있다. 3. 타입스크립트 컴파일러를 이용해 현재 파일을 자바스크립트로 변환 후 디버깅하자. npx tsc ./contents/codes/2024/2024-01/app.ts 자바스크립트로 변환된 app.js 파일에 브레이크포인트를 걸어 VSCode의 디버깅을 실행하면 이전에 나왔던 에러 없이 실행이 잘 되는 것을 확인할 수 있다. 당연하다. 자바스크립트 코드를 디버깅</p></article></a></li><li><a href="/posts/2024-01-27-fireEvent-userEvent"><article><h3 class="text-xl font-semibold">userEvent vs. fireEvent</h3><time class="mt-1 text-sm text-zinc-400">2024-01-27</time><p class="mt-4 line-clamp-3 text-zinc-700">리액트 테스팅 라이브러리는 UI 컴포넌트를 테스트하기 위한 도구다. 공식 문서의 소개글을 토대로 특징을 설명하면 테스트가 제품의 실제 사용 방식과 유사할수록, 테스트 결과에 대한 확신이 높아진다고 한다. 즉, 사용자가 애플리케이션을 실제로 사용하는 방식과 유사하게 테스트를 진행하면, 개발자는 예상대로 제품이 동작하는지 확인할 수 있으며, 동시에 사용자가 서비스를 이용하면서 예상치 못한 버그를 최소화할 수 있다. 테스팅 라이브러리는 DOM 노드를 쿼리하고 상호작용할 수 있는데 주로 두 가지 함수를 사용해서 테스트를 수행한다. 공식문서에서도 `fireEvent` 를 사용하기 보다 `userEvent` 를 사용하는 것을 권장하는데 두 함수의 차이는 `fireEvent` 는 DOM 이벤트를 발송하는 데 반해, `userEvent` 는 여러 이벤트를 발생시키고 추가적인 확인을 수행할 수 있는 완전한 상호 작용을 시뮬레이션한다. 예시를 떠올리면 클릭 이벤트를 테스트할 때 `fireEvent` 는 단순히 `dispatchEvent` 를 통해 `click` 이벤트만 발생시키지만 `userEvent` 는 마우스의 이동, 마우스 오버, 클릭 등 과 같이 실제 유저의 행동과 유사하게 처리한다. `dispatchEvent` 는 사용자 행동에 따라 반응하는 `addEventListener` 와 다르게 사용자의 동작에 반응하지 않고, 코드로 직접 이벤트를 발생시킬 수 있다. 아래 예시 코드는 버튼에 클릭 이벤트 리스너를 등록한 것이다. 따라서 사용자가 직접 버튼을 클릭해야지 `&quot;클릭 🎉&quot;` 텍스트를 볼 수 있다.   &lt;button id=&quot;event-button&quot;&gt;버튼&lt;/button&gt;   const wrap = document.getElementById(&quot;wrap&quot;);   const button = document.getElementById(&quot;event-button&quot;);   const newNode = document.createElement(&quot;span&quot;);   newNode.text</p></article></a></li></ul></section></main><div class="text-zinc-500 py-2 text-sm text-center">© <!-- -->2024<!-- --> 정소영. All rights reserved.</div><script src="/_next/static/chunks/webpack-3917685bbbc11c84.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/eaeb131c1871b7f2-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/css/4c92cc5b866ba25d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[5726,[],\"\"]\n7:I[9618,[\"618\",\"static/chunks/618-6a6cc50adaace762.js\",\"931\",\"static/chunks/app/page-3813dd42f0b14061.js\"],\"\"]\n8:I[5969,[\"618\",\"static/chunks/618-6a6cc50adaace762.js\",\"969\",\"static/chunks/969-108d58b1f108e1d8.js\",\"185\",\"static/chunks/app/layout-a46294d93785b42a.js\"],\"Image\"]\n9:I[1699,[],\"\"]\na:I[2579,[],\"\"]\nc:I[3141,[],\"\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4c92cc5b866ba25d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"zj6YS0hRJ1_OhId8Z7dNW\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"__PAGE__\",{},[[\"$L5\",\"$L6\"],null],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"__className_aaf875\",\"children\":[\"$\",\"body\",null,{\"className\":\"flex flex-col w-full max-w-screen-lg mx-auto\",\"children\":[[\"$\",\"header\",null,{\"className\":\"relative flex justify-center items-center p-8\",\"children\":[[\"$\",\"$L7\",null,{\"href\":\"/\",\"className\":\"flex flex-col items-center text-5xl\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"__className_5cd26d\",\"children\":\"Better code coffee\"}],[\"$\",\"p\",null,{\"className\":\"text-base mt-3\",\"children\":\"A blog by someone who strives for and enjoys writing better code and loves coffee\"}]]}],[\"$\",\"div\",null,{\"className\":\"absolute top-11 right-8 flex items-center gap-3 max-md:hidden\",\"children\":[[\"$\",\"a\",null,{\"href\":\"https://github.com/soyoung-baker\",\"children\":[\"$\",\"$L8\",null,{\"src\":{\"src\":\"/_next/static/media/ic_github_24.3c455590.svg\",\"height\":24,\"width\":24,\"blurWidth\":0,\"blurHeight\":0},\"alt\":\"GitHub logo\"}]}],[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/in/soyoung-jung-baker\",\"children\":[\"$\",\"$L8\",null,{\"src\":{\"src\":\"/_next/static/media/ic_linkedin_24.3e548cc1.svg\",\"height\":24,\"width\":24,\"blurWidth\":0,\"blurHeight\":0},\"alt\":\"LinkedIn logo\"}]}]]}]]}],[\"$\",\"main\",null,{\"className\":\"grow max-lg:px-3\",\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"className\":\"text-zinc-500 py-2 text-sm text-center\",\"children\":[\"© \",2024,\" 정소영. All rights reserved.\"]}]]}]}],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Home | Better code coffee 블로그\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"전체 포스트 목록을 볼 수 있습니다.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/images/icons/favicons/favicon.ico\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\n5:null\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"section\",null,{\"className\":\"pt-16 pb-20\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"font-extrabold text-2xl\",\"children\":\"POST\"}],[\"$\",\"ul\",null,{\"className\":\"flex flex-col gap-10 mt-6\",\"children\":[[\"$\",\"li\",\"2024-07-04-pnpm-action-node-version\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-07-04-pnpm-action-node-version\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"pnpm action node version 에러\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-07-04\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"PR을 올린 후 GitHub Actions가 실패하는 문제가 발생했다. 로그를 확인해보니 install pnpm 단계에서 에러가 발생한 것이었다. 내용은 아래와 같은데 어제까지 잘 작동하던 액션이 갑자기 에러를 발생시키니, 특별한 설정 변경이 없었음에도 원인을 찾기 위해 구글링을 시작했다. 똑같은 증상으로 issue 를 올린 글을 확인했다. 문제의 원인은 pnpm/action-setup 이슈에서 동일한 증상을 겪고 있는 사람들의 글을 통해 확인할 수 있었다. 해결책은 checkout 액션을 최신 버전인 v4로 업그레이드하는 것이었다. 실제로 버전을 올린 후 문제가 해결되었다. 왜 이런 문제가 발생했는지 알아보았다. GitHub Actions와 Node.js 버전 전환 작년부터 올해 GitHub Actions는 Node.js 20으로 전환하는 과정을 진행 중이었다. [GitHub Actions: Transitioning from Node 16 to Node 20](https://github.blog/changelog/2023-09-22-github-actions-transitioning-from-node-16-to-node-20/) 이러한 GitHub Actions 의 소식으로 pnpm/action-setup 에서는 아래와 같은 대화가 있었다. [node20 support](https://github.com/pnpm/action-setup/issues/99#issuecomment-1737700746) 그리고 2024년 5월 17일에 [Updated dates for Actions runner using Node20 instead of Node16 by default](https://github.blog/changelog/2024-05-17-updated-dates-for-actions-runner-using-node20-instead-of-node16-by-default/) 업데이트 글이 올라왔다. 따라서 Node.js 16으로 실행되던 pnpm/action-s\"}]]}]}]}],[\"$\",\"li\",\"2024-06-29-useRef\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-06-29-useRef\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"useRef 의 3가지 타입\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-06-29\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"React의 `useRef` 훅은 컴포넌트 렌더링 사이에 값을 저장할 수 있는 방법을 제공한다. 이는 렌더링 간에 정보를 보존해야 하지만 리렌더링을 촉발하지 않아야 하는 경우에 유용하다. `useRef`의 특징으로 아래 3가지를 가지고 있다. 요약하면, `useRef`는 React의 생명주기와 독립적으로 작동하며, 사이드 이펙트를 발생시킬 수 있는 훅이다. 공식문서에는 \\\"초기화를 제외하고 렌더링 중에 `ref.current` 를 쓰거나 읽지 마세요.\\\" 라고 경고하는데, 이는 컴포넌트의 동작을 예측할 수 없게 만들기 때문이다. react 소스 코드를 통해 `useRef` 부분을 살펴보면 `useRef`는 `current` 속성을 가진 객체를 반환한다. export function useRef\u003cT\u003e(initialValue: T): { current: T } {   const dispatcher = resolveDispatcher();   return dispatcher.useRef(initialValue); } 이 객체는 초기화된 값을 가진 상태로 반환되며, 값이 원시 타입일 경우 새로운 값이 할당될 수 있지만 객체일 경우 객체의 프로퍼티가 변경되더라도 객체 자체는 변경되지 않는다. 다시 정리하면 `useRef`는 같은 객체가 유지되어야 하기 때문에, `current` 속성을 이용해서 지속할 값을 저장한다. 이 `current` 속성을 가진 객체 자체는 변하지 않으며, 객체의 프로퍼티를 변경하더라도 참조 자체는 유지된다. 따라서 객체의 프로퍼티가 변경되어도 리렌더링이 발생하지 않는다. 이 `useRef` 를 사용할 때 초기화 하는 방법에는 아래 3가지 방법이 있다. 세 가지 경우 모두 유효하지만, 초기값으로 `null`을 넣는 경우와 그렇지 않은 경우의 차이점은 무엇일까? 여기서 `useRef` 가 가질 수 있는 값 타입을 보기 위해 타입 정보에 들어가면 아래 3가지로 나뉘는 것을 볼 수 있다.  * `useRef`는 전달된 인수(`initialValue`)로 초\"}]]}]}]}],[\"$\",\"li\",\"2024-06-16-react-useState\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-06-16-react-useState\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"useState\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-06-16\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"`useState`는 초기값을 매개변수로 받고, `[value, setState]` 형식의 배열을 리턴한다.   // do someting   return [value, setState]; } 우리가 `useState`를 사용할 때, 아래 코드처럼 그 `state`에 어울리는 이름을 붙여서 사용한다. 이게 가능한 이유는 배열은 속성 이름이 아닌 인덱스 위치로 구조 분해 할당이 가능하기 때문이다. 첫 번째, 두 번째 요소가 무슨 이름으로 지정되든 상관없이 배열에서는 0번째, 1번째 값을 반환한다. 반면, 객체로 구조 분해 할당을 실행하면 리턴 문에서 지정한 `key, value` 형태를 그대로 유지해야 한다.   // do someting   return { value, setState }; } 이렇게 되면 우리는 매번 아래처럼 이름을 재할당해줘야 한다.   // do someting   return { value, setState }; } 이러한 불필요한 작업 없이 배열을 통해 값을 받아서 사용하는 것이다. 다시 돌아와서, 받은 초기값으로 `value`를 지정하고 `setState`에는 새로운 값이 들어오면 기존 `value`에 할당하는 방식일 것이다.   let value = initValue;   function setState(newValue) {     value = newValue;   }   return [value, setState]; } 이제 이렇게 동작이 되는지 컴포넌트를 만들어서 확인해보자.   const [number, setNumber] = useState(0);   return {     onClick: () =\u003e {       setNumber(1);     },     render: () =\u003e {       console.log(number); // 0 0     },   }; } A.render(); A.onClick(); A.render(); `onClick`을 실행했음에도 여전히 0이 출력되는 것을 볼 수 있다. 이유는 `con\"}]]}]}]}],[\"$\",\"li\",\"2024-05-19-jest-act\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-05-19-jest-act\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"UserEvent 의 act 경고\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-05-19\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"import { useState } from \\\"react\\\"; import { act, fireEvent, render, screen } from \\\"@testing-library/react\\\"; import userEvent from \\\"@testing-library/user-event\\\";   const [isActive, setIsActive] = useState(false);   return (     \u003cbutton onClick={() =\u003e setIsActive((prev) =\u003e !prev)}\u003e       {isActive ? \\\"OFF\\\" : \\\"ON\\\"}     \u003c/button\u003e   ); }; describe(\\\"Button\\\", () =\u003e {   it(\\\"UserEvent with act\\\", async () =\u003e {     render(\u003cTestComponent /\u003e);     const button = screen.getByRole(\\\"button\\\", { name: \\\"ON\\\" });     expect(button).toBeInTheDocument();     await act(async () =\u003e await userEvent.click(button));     expect(button).toHaveTextContent(\\\"OFF\\\");   });   it(\\\"UserEvent without act\\\", async () =\u003e {     render(\u003cTestComponent /\u003e);     const button = screen.getByRole(\\\"button\\\", { name: \\\"ON\\\" });     expect(button).toBeInTheDocument();     await userEvent.click(button);     expect(button).toHaveTextContent(\\\"OFF\\\");   });   it(\\\"UserEvent with session without act\\\", async () =\u003e {     const user = userEvent.setup()\"}]]}]}]}],[\"$\",\"li\",\"2024-05-01-google-translate-react\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-05-01-google-translate-react\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"리액트와 구글 번역기 충돌로 인한 에러 해결 방법\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-05-01\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"최근 유저가 페이지를 이동하다가 갑자기 아래와 같은 에러 문구로 에러 페이지가 뜬다는 보고가 들어왔다. NotFoundError Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node. 관련해서 검색을 해보니 리액트로 개발된 페이지에서 구글 번역기를 사용할 경우 생기는 문제였다. 구글과 리액트에서도 이미 이 문제에 대해서 알고 있는 상태이지만 리액트와 구글, 두 팀은 이 문제를 고칠 생각은 없어 보였다. 위 링크 내용을 요약하면 구글 번역기가 동작하면서 번역된 내용이 담긴 텍스트 노드를 `\u003cfont\u003e` 태그에 감싸는데 이때 리액트는 더이상 자식 요소가 아닌 텍스트 노드에 대한 참조를 유지해서 생긴 문제다. 1. 구글 번역기를 사용하면 텍스트 노드는 `\u003cfont\u003e` 태그로 감싸진다. 2. 리액트는 더이상 자식 요소가 아닌 텍스트 노드를 참조를 계속 유지한다. 문제를 분석하기 전에 `insertBefore` 메소드에 대해서 알아보자. `insertBefore` 은 특정 노드를 참조 노드의 앞에 사용될 때 사용되는 메소드다. [mdn - Node: insertBefore() method](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) parentNode.insertBefore(newNode, referenceNode);   * 삽입할 새로운 노드   * 이미 DOM 에 존재하는 노드라면 현재 위치에서 제거되고 새로운 위치에 삽입된다.   * 참조 노드, 이 노드 앞에 `newNode` 가 삽입된다.   * 만약 `null` 일 경우, `newNode` 는 부모노드의 자식 목록의 마지막에 추가된다. 위 특징대로 간단하게 사용법을 익히면 아래와 같다.   \u003cspan id=\\\"childElement\\\"\u003e안녕!\u003c/span\u003e   const\"}]]}]}]}],[\"$\",\"li\",\"2024-04-04-git-action\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-04-04-git-action\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"SSH Key 및 Personal Access Token 설정\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-04-04\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"회사에서는 공용 키를 사용하는 것이 이상적이지만, 멤버 개인의 키를 사용하는 경우도 있을 수 있다. 이때 해당 멤버가 퇴사하면서 계정이 삭제되면 해당 멤버의 키는 모두 유효하지 않아 액션이 실패하게 된다. 따라서 아래 방법을 통해 키를 대체해야 한다. 커밋을 푸시할 때마다 아이디와 비밀번호를 입력해야 한다면 매우 불편할 것이다. SSH 키를 사용하면 이러한 불편함을 해소할 수 있다. 다음은 SSH 키를 설정하는 과정이다. vi ~/.ssh id_rsa id_rsa.pub GitHub 프로필 메뉴에서 Settings \u003e SSH and GPG keys로 이동한다. New SSH key 버튼을 클릭한다. `id_rsa.pub` 파일의 내용을 그대로 복사하여 붙여넣는다. SSH 키를 추가한 후 회사 권한을 부여해야 한다. 권한이 부여되지 않은 경우 흰색 텍스트로 Authorize 상태이다. 해당 버튼을 클릭하여 붉은 글씨로 Deauthorize 상태로 변경해야 한다. (버튼이 아닌 라벨처럼 마치 붉은 글씨가 권한이 취소된 상태처럼 보이는게 UI 가 매우 아쉽다) 등록이 끝나면 보통 바로 위 사진처럼 키가 초록색이 아닌 아래 사진처럼 흰색인데 아직 ssh 키를 사용(커밋 푸쉬 등)하지 않아서니깐 걱정하지 않아도 된다. Settings 메뉴에서 Developer settings로 이동한다. Personal access tokens \u003e Tokens (classic) \u003e Generate new token 버튼을 클릭한다. 토큰을 생성한 후 회사 권한을 활성화한다. 레포지토리 설정으로 이동하여 Settings \u003e Secrets and variables \u003e Actions \u003e New repository secret 버튼을 클릭한다. key 이름은 상관없다. 다만 workflows 에서 `secrets.` 뒤에 설정할 변수 이름과 key 가 동일해야 한다. `id_rsa` 텍스트를 그대로 복사하여 붙여넣는다. 이때 `----BEGIN` 과 `-----END` 까지 복사해서 붙여넣어\"}]]}]}]}],[\"$\",\"li\",\"2024-03-08-mock\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-03-08-mock\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"mock 이 왜 필요할까?\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-03-08\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"디자인에서는 mockup이라는 용어가 있다. 제품 디자인 수업 때, 팀원들과 함께 목업실에서 디자인한 아이디어를 형상화하기 위해 매달렸던 그때가 기억난다. 디자인에서 mockup 과정이 필요한 이유는 한 번에 요구사항에 맞게 제품을 만들 수 없기 때문이다. mockup 과정 없이 실제 제품을 만들면 요구사항과 다르다는 사실을 발견할 때마다 매번 수정해야 하므로 비용이 많이 들 것이다. 그러므로 mockup을 통해 팀원들과 함께 요구사항의 부족한 부분을 찾아내고 보완해 나가는 과정을 거치게 된다. 이러한 끊임없는 디자인 검증 과정을 거쳐 비용을 절감한 후에 프로토타입과 실제 제품을 생산할 수 있다. 개발도 이와 유사하다. 한 번에 요구사항에 맞게 개발하는 것은 어렵다. 개발에선 'mockup'이 아닌 'mock'이라는 용어를 사용한다. 이것은 가짜 데이터를 생성하는 것으로, 실제 데이터가 아니라 모의 데이터나 API 요청과 같은 것을 의미한다. 프론트엔드 개발자들은 주로 API 개발 전에 실제 API 데이터 대신 가짜 데이터나 모의 API를 사용하여 작업한다. 이렇게 하면 mock 데이터나 mock API를 사용하여 사전에 작업할 수 있다. 이와 같이 'mock'이라는 개념은 실제 제품이나 데이터를 모방하여 만든 것으로, 필요한 상황에 도구로 사용된다. 개발에 앞서, 작업 방법을 구상하고 스펙에 대한 검증이 필요한 부분을 문서를 통해 명확히 작성한다. 이후 수정이 필요한 부분이 발생하면 팀원들과 회의를 통해 스펙을 다시 확인하고 수정해 나간다. 팀 전체가 스펙에 대해 명확하게 이해하면 개발을 시작한다. 초기에는 백엔드에서 데이터를 받을 수 없을테니 mock 데이터를 사용하여 개발을 진행한다. 테스트 코드를 작성할 수 있다면 테스트 코드를 통해 예상한 mock 데이터를 활용하여 개발을 진행하고, 스펙에 미흡한 부분이 발견되면 즉시 팀원들과 다시 논의를 거쳐 수정한다. 또한, 중간에 스펙 변경 요청이 들어오면 그에 따라 새로운 기능을 추가해서 테스트 결과를 보면 어\"}]]}]}]}],[\"$\",\"li\",\"2024-02-10-date\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-02-10-date\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"Date: \\\"네가 뭘 좋아할지 몰라서 다 준비했어\\\"\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-02-10\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"GMT는 태양을 기준으로 한 그리니치 평균시로, 영국 그리니치 천문대를 지나는 본초자오선(경도 0도)을 기준으로 한다. 지구를 약 15도씩 나눠서 24개의 시간대를 만든 것이다. TMI 로 '본초자오선'이라는 용어가 입에 잘 붙지 않아 찾아보니 다음과 같은 의미를 담고 있다. 즉, 본초자오선(本初子午線)은 북쪽과 남쪽을 잇는 선 중에서 가장 처음이 되는 기준선이라는 뜻이다. 1967년 '초' 라는 시간 단위 정의가 바뀌었는데 기존에는 지구가 한 바퀴 자전하는 것을 24시간으로 삼았지만 태양이 뜨고 지는 시간, 즉 지구가 한 바퀴 자전하는 시간을 `하루를 24시간 * 1시간 60분 * 1분 60초 = 86,400` 으로 나눈 단위였다. 하지만 과학자들은 지구의 자전의 속도가 미세하게 느려지고 있다는 것을 알게됐고 우주 어디에서도 절대 변하지 않는 시간 단위, 원자 시계 기반 시계 기준(UTC)을 만들었다. UTC는 원자 시계를 기준으로 한 전 세계 시간의 기준이다. 세슘 원자의 진동수를 기준이 원자 시계다.(TMI: 세슘 원자로 정한 이유는 세슘 원자는 온도, 압력 같은 외부 조건에 영향을 받지 않고 원자의 진동 주기가 매우 안정적으로 일정하기 때문이라고 한다.) 지구의 자전 속도에 따라 미세하게 느려진 GMT 와 다르게 UTC 는 지구의 자전 속도와 원자 시계의 간격을 위해 필요할 때, 6월 30일 혹은 12월 31일에 1초를 추가하거나 삭제하면서 '초'의 정의를 바꾸지 않고 시간을 보정할 수 있다. UTC+0:00이 영국 시간이다. 이 시간대를 기준으로 각 지역의 시차를 정하는데, 예를 들어 한국은 영국보다 9시간 빠른 UTC+09:00이다. (빠르다는 것은 영국보다 한국이 9시간 앞서 있다, 지났다는 것을 의미) ISO 8601은 국제 표준으로 정의된 날짜 및 시간 표기 형식이다. 이 형식은 다음과 같다: 날짜: yyyy-mm-dd 시간: hh:mm:ss (날짜와 시간 사이에 T를 사용) 예: 2023-12-01T09:00:00Z (Z는 UTC 시간을 나타\"}]]}]}]}],[\"$\",\"li\",\"2024-01-28-debug-tool\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-01-28-debug-tool\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"VSCode 에서 타입스크립트 디버깅하기\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-01-28\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"VSCode에서 타입스크립트로 작성한 코드를 디버그하려고 하면 에러가 발생한다.   return `${name}.github.io`; } printBlogURL(blogName); VSCode에서 타입스크립트 디버그를 어떻게 할 수 있을까? [공식문서](https://code.visualstudio.com/docs/typescript/typescript-debugging)에는 아래와 같이 적혀있다. \u003e VS Code has built-in debugging support for the Node.js runtime and can debug JavaScript, TypeScript, or any other language that gets transpiled to JavaScript. VSCode는 Node.js 런타임에 대한 내장 디버깅 지원을 제공하며 JavaScript, TypeScript 또는 JavaScript로 변환되는 다른 언어를 디버깅할 수 있다. \u003e Visual Studio Code supports TypeScript debugging through its built-in Node.js debugger and Edge and Chrome debugger. Visual Studio Code는 내장된 Node.js 디버거와 Edge 및 Chrome 디버거를 통해 TypeScript 디버깅을 지원한다. 1. VSCode는 자바스크립트 런타임 환경에 내장한 디버깅을 지원한다. 2. 즉, 타입스크립트로 작성한 코드는 자바스크립트로 변환된 상태여야 자바스크립트 런타임 환경에 내장한 디버깅을 쓸 수 있다. 3. 타입스크립트 컴파일러를 이용해 현재 파일을 자바스크립트로 변환 후 디버깅하자. npx tsc ./contents/codes/2024/2024-01/app.ts 자바스크립트로 변환된 app.js 파일에 브레이크포인트를 걸어 VSCode의 디버깅을 실행하면 이전에 나왔던 에러 없이 실행이 잘 되는 것을 확인할 수 있다. 당연하다. 자바스크립트 코드를 디버깅\"}]]}]}]}],[\"$\",\"li\",\"2024-01-27-fireEvent-userEvent\",{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/posts/2024-01-27-fireEvent-userEvent\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold\",\"children\":\"userEvent vs. fireEvent\"}],[\"$\",\"time\",null,{\"className\":\"mt-1 text-sm text-zinc-400\",\"children\":\"2024-01-27\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 line-clamp-3 text-zinc-700\",\"children\":\"리액트 테스팅 라이브러리는 UI 컴포넌트를 테스트하기 위한 도구다. 공식 문서의 소개글을 토대로 특징을 설명하면 테스트가 제품의 실제 사용 방식과 유사할수록, 테스트 결과에 대한 확신이 높아진다고 한다. 즉, 사용자가 애플리케이션을 실제로 사용하는 방식과 유사하게 테스트를 진행하면, 개발자는 예상대로 제품이 동작하는지 확인할 수 있으며, 동시에 사용자가 서비스를 이용하면서 예상치 못한 버그를 최소화할 수 있다. 테스팅 라이브러리는 DOM 노드를 쿼리하고 상호작용할 수 있는데 주로 두 가지 함수를 사용해서 테스트를 수행한다. 공식문서에서도 `fireEvent` 를 사용하기 보다 `userEvent` 를 사용하는 것을 권장하는데 두 함수의 차이는 `fireEvent` 는 DOM 이벤트를 발송하는 데 반해, `userEvent` 는 여러 이벤트를 발생시키고 추가적인 확인을 수행할 수 있는 완전한 상호 작용을 시뮬레이션한다. 예시를 떠올리면 클릭 이벤트를 테스트할 때 `fireEvent` 는 단순히 `dispatchEvent` 를 통해 `click` 이벤트만 발생시키지만 `userEvent` 는 마우스의 이동, 마우스 오버, 클릭 등 과 같이 실제 유저의 행동과 유사하게 처리한다. `dispatchEvent` 는 사용자 행동에 따라 반응하는 `addEventListener` 와 다르게 사용자의 동작에 반응하지 않고, 코드로 직접 이벤트를 발생시킬 수 있다. 아래 예시 코드는 버튼에 클릭 이벤트 리스너를 등록한 것이다. 따라서 사용자가 직접 버튼을 클릭해야지 `\\\"클릭 🎉\\\"` 텍스트를 볼 수 있다.   \u003cbutton id=\\\"event-button\\\"\u003e버튼\u003c/button\u003e   const wrap = document.getElementById(\\\"wrap\\\");   const button = document.getElementById(\\\"event-button\\\");   const newNode = document.createElement(\\\"span\\\");   newNode.text\"}]]}]}]}]]}]]}]\n"])</script></body></html>